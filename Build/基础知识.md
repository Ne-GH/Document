# 前置知识
## 基本的编译链接知识，源码到二进制怎么来的
    1、预处理（宏展开）  
    2、汇编（代码文件产生汇编文件）  
    3、编译（汇编文件编译为obj文件）  
    4、链接（obj文件进行链接）  

## linux/windows 编译产物的差异
| linux产物 | windows产物        | 说明                                                                               |
|---------|------------------|----------------------------------------------------------------------------------|
| .o      | .obj             | 中间文件，含了编译后的机器代码、符号表（其中记录了函数名、变量名等符号信息）和重定位信息                                     |
| .out    | .exe             | 最终生成的可执行文件，其中linux下的可执行文件不一定有后缀                                                  |
| .a      | .lib(object lib) | 静态库, 链接时静态库会被复制进可执行文件中                                                           |
| .so     | .dll/.ock        | 动态库，linux下动态库使用仅需要so文件，windows下使用dll需要有import lib文件                              |
| .ko     | \                | linux内核特有的编译产物,内核模块可以在运行时动态地加载到内核中或者从内核中卸载，用于扩展内核的功能                             |
| \       | .sys             | 用于 windows 操作系统的设备驱动程序编译后会生成.sys 文件                                              |
| \       | .res             | 资源文件（.rc）用于存储程序的非代码资源, 这些资源文件在编译时会被转换成二进制的.res 文件，然后与其他目标文件一起链接到最终的可执行文件或动态链接库中。 |
| \       | .lib(import lib) | 包含了dll中函数和符号信息, 用于在编译链接阶段帮助程序找到dll中的函数和符号                                        |
| \       | .exp             | 用于在创建dll时记录dll中的导出函数和数据                                                          |
| \       | .pdb             | PDB 文件是windows用于存储调试信息的文件。它包含了程序的详细结构信息，如函数、变量、类型等信息，并且记录了代码的编译和链接过程中的许多细节       |

## 名词解释
| 名称        | 解释                                   |
|-----------|--------------------------------------|
| libstdc   | gcc自带的c标准库实现                         |
| glibc     | 标准库实现，除了c标准库外，添加了许多和linux相关的功能       |
| ucrt      | windows下通用C标准库,更现代,对C++提供间接支持（如内存管理） |
| libstdc++ | gcc自带的c++标准库实现                       |
| msvcrt    | 早期的 Microsoft Visual C++ 运行时库        |

## glib break的原因
    glib break 可能是因为版本升级时，其API可能会发生变化，如果程序基于就的glib开发，在更新glib之后没有对相应代码进行修改，可能会出现兼容性问题。
    比如就版本的glib中某个函数的参数类型或者返回值在新版本中发生了改变，那么原来使用该函数的程序代码可能无法正常工作。

## ucrt不同的版本能否混用
    ucrt 不同版本的内部实现细节，函数接口定义和行为可能发生改变，虽然会尽量保持向后兼容，但是混用不同的版本仍可能出现问题。
    例如malloc函数，不同版本的实现返回的内存块结构可能不同，混用会导致内存泄漏、非法访问等问题

