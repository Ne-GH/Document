/*
 * C 标准库的实现一般是通过系统调用实现的,在程序中我们可以直接调用C 标准库函数或者直接进行系统调用
 */
/* 例如: 我们C 标准库中的fopen函数就是通过调用系统的open函数实现的,我们可以调用fopen也可以直接调用open函数 */

/* 我们称open等系统函数为无缓冲I/O(UnBuffer I/O)函数,因为他们在C标准库I/O的底层 */

/* 区别:
 *  UnBuffer I/O每次调用都需要进入系统内核,调一个系统调用比调一个用户空间的函数,呒,慢的多,因此有必要在用户空间创建I/O缓冲区,即调用C标准I/O
 *  由于在用户空间创建了I/O缓冲区,因此因该意识到,试图写入的内容和真正写入内核的内容可能不一直,缓冲区中可能有存留,应该调用fflush清空buffer
 *  读写设备时,我们一般希望直接进行读写,而不希望存在buffer,因此这时UnBuffer就更有优势
 */

/* 实际上open这样的系统调用也会维护一个内核缓冲区,因此UnBuffer并不很确切,但确实是这个名字...... ,不过这样的系统缓冲区对于进程来说是没有区别的*/
/* fcnlt 可以改变open的打开属性,而不必close之后再次open */





/* 调用read/write等函数可能引起阻塞 */
/* 当进程调用一个阻塞的系统函数时,该进程被置于睡眠状态,这时内核调度其他进程执行,直到该进程等待的事情发生(睡眠时间到了,或者接收到了数据),才又可能继续运行 */
/* 运行中的程序则分为以下两个状态:被调度执行以及就绪(程序随时都能运行但是CPU还在调度其他程序,调度会根据优先级,用户体验等进行) */






/* fseek 的偏移量如果超过了文件尾,那么下次写操作将延长文件,中间空余部分填0 
 * 这种方法可以用来判断操作对象是普通的文件还是设备,fseek成功返回0,失败返回-1
 * lseek成功时返回当前偏移量,失败时返回-1,并将errno设置为ESPIPE
 */

